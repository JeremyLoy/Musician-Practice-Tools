<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Musician's Practice Toolkit</title>
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    <style>
        :root {
            --primary: #22c55e;
            --danger: #ef4444;
            --bg: #0f172a;
            --surface: #1e293b;
            --border: #334155;
            --text: #f1f5f9;
            --text-muted: #94a3b8;
        }
        *, *::before, *::after { box-sizing: border-box; }
        body { font-family: system-ui,-apple-system,sans-serif; background: var(--bg); color: var(--text); max-width: 860px; margin: 0 auto; padding: 1.5rem; line-height: 1.5; }
        h1 { text-align: center; margin: 0 0 1.5rem; font-weight: 800; font-size: clamp(1.3rem,5vw,2rem); }
        h2 { margin: 0 0 1.2rem; color: var(--text-muted); font-size: 0.78rem; text-transform: uppercase; letter-spacing: 1.5px; }

        .card { background: var(--surface); border: 2px solid var(--border); border-radius: 16px; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: 0 10px 25px -5px rgba(0,0,0,0.4); transition: border-color 0.06s ease-out, box-shadow 0.06s ease-out; }
        .card.beat-flash { border-color: var(--primary) !important; box-shadow: 0 0 0 4px rgba(34,197,94,0.28), 0 10px 25px -5px rgba(0,0,0,0.4) !important; }


        /* DRONE */
        .drone-section { display: flex; flex-direction: column; gap: 1.2rem; }
        .selector-label { display: block; font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 0.4rem; font-weight: 700; }
        .root-grid { display: grid; grid-template-columns: repeat(6,1fr); gap: 5px; }
        .interval-grid { display: grid; grid-template-columns: repeat(auto-fill,minmax(56px,1fr)); gap: 5px; }
        .btn-toggle { background: var(--bg); border: 1px solid var(--border); color: var(--text); padding: 12px 3px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 600; transition: all 0.15s; touch-action: manipulation; min-height: 44px; }
        .btn-toggle:hover:not(.active) { border-color: var(--primary); color: var(--primary); }
        .btn-toggle:active { opacity: 0.75; }
        .btn-toggle.active { background: var(--primary); border-color: var(--primary); color: #fff; }

        .settings-bar { display: flex; flex-direction: column; gap: 10px; padding: 1rem; background: rgba(0,0,0,0.3); border-radius: 12px; border: 1px solid var(--border); }
        .drone-row { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
        .drone-row .control-group { flex: 1; width: 0; }
        .drone-row .control-group .stepper { width: 100%; justify-content: space-between; }
        .drone-row .control-group .stepper .stepper-val { flex: 1; }
        .drone-row .switch-ui { width: 100%; }
        .drone-row .switch-ui button { flex: 1; }
        .control-group { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .switch-ui { display: flex; background: var(--bg); border-radius: 8px; padding: 3px; border: 1px solid var(--border); }
        .switch-ui button { background: transparent; color: var(--text-muted); border: none; padding: 10px 12px; font-size: 0.68rem; border-radius: 5px; cursor: pointer; font-weight: 700; min-height: 44px; touch-action: manipulation; transition: all 0.15s; }
        .switch-ui button:active { opacity: 0.75; }
        .switch-ui button.active { background: var(--primary); color: #fff; }

        .vol-row { display: flex; align-items: center; gap: 8px; width: 100%; }
        .vol-row input[type=range] { flex: 1; }
        input[type=range] { accent-color: var(--primary); cursor: pointer; width: 88px; height: 20px; }
        input[type=range]::-webkit-slider-thumb { width: 28px; height: 28px; }
        input[type=range]::-moz-range-thumb { width: 28px; height: 28px; border-radius: 50%; background: var(--primary); border: none; }

        #debug-console { background: #000; color: var(--primary); font-family: 'Courier New',monospace; font-size: 0.72rem; padding: 10px; border-radius: 8px; margin-top: 0.5rem; min-height: 65px; border: 1px solid #166534; white-space: pre-wrap; }
        .details-btn { background: none; border: none; color: var(--text-muted); font-size: 0.73rem; cursor: pointer; padding: 3px 0; text-decoration: underline; }

        /* METRONOME */
        .metro-layout { display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: flex-start; justify-content: center; }
        .wheel-col { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .wheel-outer { position: relative; width: 200px; height: 200px; user-select: none; touch-action: none; }
        #wheel { width: 100%; height: 100%; border-radius: 50%; background: radial-gradient(circle,#1e293b 30%,#0f172a 100%); border: 12px solid var(--border); cursor: grab; transition: border-color 0.06s, box-shadow 0.06s; }
        #wheel.beat-flash { border-color: var(--primary); box-shadow: 0 0 22px rgba(34,197,94,0.5); }
        #wheel::after { content:''; position: absolute; top: 2px; left: 50%; transform: translateX(-50%); width: 20px; height: 20px; background: var(--primary); border-radius: 50%; }
        .bpm-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); text-align: center; width: 130px; pointer-events: none; z-index: 2; }
        #bpm-display { font-size: 3.2rem; font-weight: 900; color: var(--text); cursor: pointer; line-height: 1; pointer-events: auto; }
        #bpm-input { width: 100%; background: transparent; border: none; color: var(--primary); font-size: 3.2rem; font-weight: 900; text-align: center; display: none; outline: none; pointer-events: auto; }
        #bpm-label { font-size: 0.62rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-top: 2px; }
        .bpm-adj { display: flex; align-items: center; gap: 8px; }
        .adj-btn { background: var(--bg); border: 1px solid var(--border); color: var(--text); width: 44px; height: 44px; border-radius: 50%; font-size: 1.2rem; cursor: pointer; font-weight: 700; display: flex; align-items: center; justify-content: center; transition: all 0.15s; touch-action: manipulation; }
        .adj-btn:hover { border-color: var(--primary); color: var(--primary); }
        .adj-btn:active { background: var(--primary); border-color: var(--primary); color: #fff; }

        .wheel-row { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .wheel-and-adj { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
        .start-tap-col { display: flex; flex-direction: row; gap: 0.5rem; width: 200px; }
        .metro-start-btn { flex: 2; font-size: 1.4rem; line-height: 1.4; border-radius: 14px; padding: 0.9rem 0.5rem; text-align: center; }
        .metro-tap-btn { flex: 1; font-size: 0.85rem; line-height: 1.4; text-align: center; padding: 0.5rem; border-radius: 10px; }
        .metro-controls { display: flex; flex-direction: column; gap: 1rem; flex: 1; min-width: 205px; }
        .seg-ctrl { display: flex; background: var(--bg); border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        .seg-ctrl button { flex: 1; background: transparent; color: var(--text-muted); border: none; border-right: 1px solid var(--border); padding: 12px 2px; font-size: 0.7rem; font-weight: 700; cursor: pointer; transition: all 0.15s; touch-action: manipulation; min-height: 44px; }
        .seg-ctrl button:last-child { border-right: none; }
        .seg-ctrl button:active { opacity: 0.75; }
        .seg-ctrl button.active { background: var(--primary); color: #fff; }
        .mode-row { display: flex; gap: 8px; }

        /* TIME SIGNATURE INPUT */
        .ts-input-row { display:flex; align-items:center; gap:10px; }
        .ts-text-input {
            background: var(--bg); border: 2px solid var(--border); color: var(--primary);
            font-size: 1.6rem; font-weight: 900; text-align: center;
            border-radius: 10px; padding: 8px 12px; width: 110px;
            outline: none; transition: border-color 0.15s; touch-action: manipulation;
            min-height: 44px; letter-spacing: 1px;
        }
        .ts-text-input:focus { border-color: var(--primary); }
        .ts-text-input.error { border-color: var(--danger); color: var(--danger); }
        .ts-hint { font-size: 0.68rem; color: var(--text-muted); line-height: 1.5; }

        /* VIEWPORT FLASH */
        #viewport-flash { position: fixed; inset: 0; pointer-events: none; z-index: 9999; border: 0px solid var(--primary); transition: border-width 0.04s ease-out, opacity 0.04s ease-out; opacity: 0; }
        #viewport-flash.beat-flash { border-width: 12px; opacity: 1; }
        #viewport-flash.beat-flash.accent { border-width: 18px; }

        /* RECORDER */
        .recording-item { background: var(--surface); border: 1px solid var(--border); padding: 1.2rem; margin-bottom: 1rem; border-radius: 14px; }
        .wf-box { height: 88px; background: rgba(0,0,0,0.5); border-radius: 8px; margin: 12px 0; overflow: hidden; }
        #memoList { max-height: 420px; overflow-y: auto; overscroll-behavior: contain; margin-top: 1rem; }
        #memoList:empty { margin-top: 0; }

        /* DICTIONARY */
        .dict-search { width: 100%; padding: 10px 14px; font-size: 1rem; font-weight: 600; background: var(--bg); border: 2px solid var(--border); color: var(--text); border-radius: 10px; outline: none; transition: border-color 0.15s; min-height: 44px; box-sizing: border-box; margin-bottom: 0.75rem; }
        .dict-search:focus { border-color: var(--primary); }
        .dict-results { height: 380px; overflow-y: auto; overscroll-behavior: contain; }
        .dict-item { display: flex; align-items: baseline; gap: 10px; padding: 10px 4px; border-bottom: 1px solid var(--border); }
        .dict-item:last-child { border-bottom: none; }
        .dict-term { font-weight: 700; font-size: 0.95rem; color: var(--text); flex-shrink: 0; }
        .dict-lang { font-size: 0.6rem; font-weight: 700; color: var(--bg); background: var(--text-muted); border-radius: 4px; padding: 2px 5px; flex-shrink: 0; text-transform: uppercase; letter-spacing: 0.5px; }
        .dict-def { font-size: 0.82rem; color: var(--text-muted); flex: 1; min-width: 0; }
        .dict-empty { color: var(--text-muted); font-size: 0.85rem; padding: 1rem 0; text-align: center; }

        /* TUNER */
        .tuner-body { display: flex; flex-direction: column; gap: 1.2rem; }
        .tuner-note-display { text-align: center; min-height: 90px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 0.25rem; }
        .tuner-note-name { font-size: 3.5rem; font-weight: 900; color: var(--text); line-height: 1; }
        .tuner-note-name sup { font-size: 1.5rem; font-weight: 700; vertical-align: super; color: var(--text-muted); }
        .tuner-note-name sub { font-size: 1.5rem; font-weight: 700; vertical-align: sub; color: var(--text-muted); }
        .tuner-cents { font-size: 1.1rem; font-weight: 700; color: var(--text-muted); min-height: 1.4rem; }
        .tuner-cents.in-tune   { color: var(--primary); }
        .tuner-cents.near-tune { color: #eab308; }
        .tuner-cents.out-tune  { color: var(--danger); }
        .tuner-meter-wrap { display: flex; flex-direction: column; gap: 6px; }
        .tuner-meter-track { position: relative; height: 18px; background: var(--bg); border: 1px solid var(--border); border-radius: 9px; overflow: hidden; width: 100%; }
        .tuner-meter-fill { position: absolute; top: 0; bottom: 0; transition: width 0.08s ease-out, left 0.08s ease-out, background 0.15s; border-radius: 6px; }
        .tuner-meter-fill.in-tune   { background: var(--primary); }
        .tuner-meter-fill.near-tune { background: #eab308; }
        .tuner-meter-fill.out-tune  { background: var(--danger); }
        .tuner-meter-center { position: absolute; top: 0; bottom: 0; left: 50%; transform: translateX(-50%); width: 2px; background: var(--text-muted); z-index: 2; }
        .tuner-tick { position: absolute; top: 0; bottom: 0; width: 1px; background: var(--border); transform: translateX(-50%); z-index: 1; }
        .tuner-meter-labels { display: flex; justify-content: space-between; font-size: 0.65rem; color: var(--text-muted); padding: 0 2px; }
        .tuner-status { font-size: 0.82rem; color: var(--text-muted); text-align: center; min-height: 1.2rem; }
        .tuner-status.error { color: var(--danger); }

        /* BUTTONS */
        button.main-action { background: var(--primary); color: #fff; border: none; padding: 0.7rem 1.4rem; border-radius: 10px; font-weight: 700; cursor: pointer; font-size: 0.92rem; touch-action: manipulation; transition: filter 0.15s; min-height: 44px; }
        button.main-action:hover { filter: brightness(1.1); }
        button.main-action:active { filter: brightness(0.9); }
        button.main-action.is-active { background: var(--danger); }
        button.secondary { background: var(--border); color: var(--text); padding: 0.7rem 1.3rem; border-radius: 10px; font-weight: 700; cursor: pointer; border: 1px solid transparent; font-size: 0.92rem; touch-action: manipulation; transition: all 0.15s; min-height: 44px; }
        button.secondary:hover { border-color: var(--primary); }
        button.secondary:active { border-color: var(--primary); filter: brightness(1.15); }
        .num-input { background: var(--bg); border: 1px solid var(--border); color: var(--primary); padding: 5px; border-radius: 4px; width: 52px; text-align: center; font-weight: 700; }
        .stepper { display: flex; align-items: center; background: var(--bg); border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        .stepper-btn { background: transparent; border: none; color: var(--text); font-size: 1.1rem; font-weight: 700; cursor: pointer; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; touch-action: manipulation; transition: background 0.1s; flex-shrink: 0; }
        .stepper-btn:hover { background: var(--border); }
        .stepper-btn:active { background: var(--primary); color: #fff; }
        .stepper-val { color: var(--primary); font-weight: 700; font-size: 0.9rem; min-width: 40px; text-align: center; padding: 0 2px; }

        /* RESPONSIVE ‚Äî mobile/tablet first */
        @media (max-width: 600px) {
            body { padding: 1rem 0.75rem; }
            .card { padding: 1rem; }
            .btn-toggle { font-size: 0.72rem; padding: 12px 4px; }
            .seg-ctrl button { font-size: 0.65rem; padding: 12px 2px; }
            button.main-action, button.secondary { padding: 0.6rem 1rem; font-size: 0.85rem; }
            .settings-bar { gap: 8px; padding: 0.75rem; }

            /* Metronome: stack wheel column full-width, controls below */
            .metro-layout { flex-direction: column; gap: 1rem; }
            .wheel-col { width: 100%; }

            /* Wheel row: wheel centred, Start+Tap beside it */
            .wheel-row { flex-direction: row; align-items: center; justify-content: center; gap: 1rem; }
            .wheel-outer { width: 160px; height: 160px; }
            #bpm-display { font-size: 2.6rem; }
            .wheel-and-adj { align-items: center; }
            .bpm-adj { justify-content: center; }

            /* Start/Tap: tall column to the right of the wheel */
            .start-tap-col { flex-direction: column; width: 96px; gap: 0.5rem; }
            .metro-start-btn { flex: 1; font-size: 1.4rem; padding: 0.75rem 0.5rem; }
            .metro-tap-btn { font-size: 1rem; padding: 0.6rem 0.5rem; }

            /* Controls: full width */
            .metro-controls { width: 100%; min-width: unset; }

            /* Drone settings */
            .drone-row { gap: 8px; }
        }
    </style>
</head>
<body>

<h1>üéµ Musician's Practice Toolkit</h1>


<!-- DRONE -->
<div class="card">
    <h2>Drone Machine</h2>
    <div class="drone-section">
        <div>
            <span class="selector-label">1. Root Note</span>
            <div class="root-grid" id="rootGrid"></div>
        </div>
        <div>
            <span class="selector-label">2. Chord Intervals</span>
            <div class="interval-grid" id="intervalGrid"></div>
        </div>
        <div class="settings-bar">
            <div class="drone-row">
                <div class="control-group">
                    <span class="selector-label">A Ref</span>
                    <div class="stepper">
                        <button class="stepper-btn" id="droneRefMinus">‚àí</button>
                        <span class="stepper-val" id="droneRefVal">440</span>
                        <button class="stepper-btn" id="droneRefPlus">+</button>
                    </div>
                </div>
                <div class="control-group">
                    <span class="selector-label">Octave</span>
                    <div class="stepper">
                        <button class="stepper-btn" id="droneOctaveMinus">‚àí</button>
                        <span class="stepper-val" id="droneOctaveVal">4</span>
                        <button class="stepper-btn" id="droneOctavePlus">+</button>
                    </div>
                    <input type="hidden" id="droneOctave" value="4" min="1" max="6">
                </div>
            </div>
            <div class="drone-row">
                <span class="selector-label">Volume</span>
                <div class="vol-row"><span style="font-size:0.85rem;">üîà</span><input type="range" id="droneVolume" min="0" max="1" step="0.05" value="0.7"><span style="font-size:0.85rem;">üîä</span></div>
            </div>
            <div class="drone-row">
                <div class="control-group">
                    <span class="selector-label">Tuning</span>
                    <div class="switch-ui" id="tuningSwitch">
                        <button data-val="just" class="active">JUST</button>
                        <button data-val="equal">ET</button>
                    </div>
                </div>
                <div class="control-group">
                    <span class="selector-label">Wave</span>
                    <div class="switch-ui" id="colorSwitch">
                        <button data-val="sine" class="active">SINE</button>
                        <button data-val="triangle">TRI</button>
                    </div>
                </div>
            </div>
            <div class="drone-row">
                <button id="droneToggle" class="main-action" style="flex:1;">üéµ Start Drone</button>
                <button id="droneClear" class="secondary" style="flex:1;">üßπ Clear</button>
            </div>
        </div>
        <div>
            <button class="details-btn" id="detailsToggle">üî¨ Show Details</button>
            <div id="debug-console" style="display:none;"></div>
        </div>
    </div>
</div>

<!-- METRONOME -->
<div class="card" id="metro-card">
    <h2>Metronome</h2>
    <div class="metro-layout">
        <div class="wheel-col">
            <div class="wheel-row">
                <div class="wheel-and-adj">
                    <div class="wheel-outer">
                        <div class="bpm-container">
                            <div id="bpm-display">120</div>
                            <input type="number" id="bpm-input" min="40" max="280" inputmode="numeric">
                            <div id="bpm-label">BPM</div>
                        </div>
                        <div id="wheel"></div>
                    </div>
                    <div class="bpm-adj">
                        <button class="adj-btn" id="bpmMinus">‚àí</button>
                        <span style="font-size:0.68rem;color:var(--text-muted);">fine adjust</span>
                        <button class="adj-btn" id="bpmPlus">+</button>
                    </div>
                </div>
                <div class="start-tap-col">
                    <button id="metroStartBtn" class="main-action metro-start-btn">‚ñ∂<br>Start</button>
                    <button id="tapBtn" class="secondary metro-tap-btn">üëÜ<br>Tap</button>
                </div>
            </div>
        </div>
        <div class="metro-controls">
            <div class="settings-bar">
                <div>
                    <span class="selector-label">Time Signature</span>
                    <div class="ts-input-row">
                        <input type="text" id="tsInput" class="ts-text-input" inputmode="text" autocomplete="off" spellcheck="false" placeholder="4/4">
                        <span class="ts-hint">e.g. 4/4, 3/4, 6/8, 7/8</span>
                    </div>
                </div>
                <div>
                    <span class="selector-label">Subdivision</span>
                    <div class="seg-ctrl" id="subdivCtrl">
                        <button data-val="1" class="active">‚ô© Beat</button>
                        <button data-val="2">‚ô™ 8th</button>
                        <button data-val="3">‚ô©¬≥ Trip</button>
                        <button data-val="4">‚ô¨ 16th</button>
                    </div>
                </div>
                <div>
                    <span class="selector-label">Click Sound</span>
                    <div class="seg-ctrl" id="clickSoundCtrl">
                        <button data-val="clave" class="active">Clave</button>
                        <button data-val="click">Click</button>
                        <button data-val="rim">Rim</button>
                        <button data-val="cowbell">Cowbell</button>
                    </div>
                </div>
                <div id="metro-vol-row">
                    <span class="selector-label">Volume</span>
                    <div class="vol-row"><span style="font-size:0.85rem;">üîá</span><input type="range" id="metroVolume" min="0" max="1" step="0.05" value="0.7"><span style="font-size:0.85rem;">üîä</span></div>
                </div>
                <div>
                    <span class="selector-label">Output</span>
                    <div class="mode-row">
                        <button id="soundToggle" class="btn-toggle" style="flex:1;">üîî Sound</button>
                        <button id="lightToggle" class="btn-toggle" style="flex:1;">‚ö° Light</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- AUDIO MEMOS -->
<div class="card">
    <h2>Audio Memos</h2>
    <div style="text-align:center;">
        <button id="recordToggle" class="main-action">üéôÔ∏è Start Recording</button>
    </div>
    <div id="rec-status" style="margin-top:0.75rem;height:20px;color:var(--primary);font-weight:700;font-size:0.8rem;text-align:center;"></div>
    <canvas id="liveWaveform" height="80" style="width:100%;display:none;border-radius:8px;background:rgba(0,0,0,0.5);margin-top:0.75rem;"></canvas>
    <div id="memoList"></div>
</div>

<!-- CHROMATIC TUNER -->
<div class="card" id="tuner-card">
    <h2>Chromatic Tuner</h2>
    <div class="tuner-body">
        <div class="tuner-note-display">
            <div class="tuner-note-name" id="tunerNoteName">‚Äî</div>
            <div class="tuner-cents" id="tunerCentsDisplay"></div>
        </div>
        <div class="tuner-meter-wrap">
            <div class="tuner-meter-track">
                <div class="tuner-meter-fill" id="tunerMeterFill"></div>
                <div class="tuner-meter-center"></div>
                <div class="tuner-tick" style="left:0%"></div>
                <div class="tuner-tick" style="left:25%"></div>
                <div class="tuner-tick" style="left:50%"></div>
                <div class="tuner-tick" style="left:75%"></div>
                <div class="tuner-tick" style="left:100%"></div>
            </div>
            <div class="tuner-meter-labels">
                <span>-50</span><span>-25</span><span>0</span><span>+25</span><span>+50</span>
            </div>
        </div>
        <div class="settings-bar">
            <div class="drone-row">
                <div class="control-group">
                    <span class="selector-label">Tuner</span>
                    <button id="tunerToggle" class="main-action">üé§ Start Tuner</button>
                </div>
                <div class="control-group">
                    <span class="selector-label">A Ref</span>
                    <div class="stepper">
                        <button class="stepper-btn" id="tunerRefMinus">‚àí</button>
                        <span class="stepper-val" id="tunerRefVal">440</span>
                        <button class="stepper-btn" id="tunerRefPlus">+</button>
                    </div>
                </div>
            </div>
            <div id="tunerStatus" class="tuner-status"></div>
        </div>
    </div>
</div>

<!-- MUSICAL DICTIONARY -->
<div class="card">
    <h2>Musical Dictionary</h2>
    <input type="text" id="dictSearch" class="dict-search" placeholder="Search terms‚Ä¶" autocomplete="off" spellcheck="false" inputmode="text">
    <div id="dictResults" class="dict-results"></div>
</div>

<script type="module">
import DICT from './dictionary.js';

// 1. Inline the base64 string directly (No import needed!)
const silenceDataURI = "data:audio/mpeg;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAADAAAGhgBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr///////////////////////////////////////////8AAAA5TEFNRTMuOThyAc0AAAAAAAAAABSAJAiqQgAAgAAABobxtI73AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//uQxAACFEII9ACZ/sJZwWEoEb8w/////N//////JcxjHjf+7/v/H2PzCCFAiDtGeyBCIx7bJJ1mmEEMy6g8mm2c8nrGABB4h2Mkmn//4z/73u773R5qHHu/j/w7Kxkzh5lWRWdsifCkNAnY9Zc1HvDAhjhSHdFkHFzLmabt/AQxSg2wwzLhHIJOBnAWwVY4zrhIYhhc2kvhYDfQ4hDi2Gmh5KyFn8EcGIrHAngNgIwVIEMf5bzbAiTRoAD///8z/KVhkkWEle6IX+d/z4fvH3BShK1e5kmjkCMoxVmXhd4ROlTKo3iipasvTilY21q19ta30/v/0/idPX1v8PNxJL6ramnOVsdvMv2akO0iSYIzdJFirtzWXCZicS9vHqvSKyqm5XJBdqBwPxyfJdykhWTZ0G0ZyTZGpLKxsNwwoRhsx3tZfhwmeOBVISm3impAC/IT/8hP/EKEM1KMdVdVKM2rHV4x7HVXZvbVVKN/qq8CiV9VL9jjH/6l6qf7MBCjZmOqsAibjcP+qqqv0oxqpa/NVW286hPo1nz2L/h8+jXt//uSxCmDU2IK/ECN98KKtE5IYzNoCfbw+u9i5r8PoadUMFPKqWL4LK3T/LCraMSHGkW4bpLXR/E6LlHOVQxmslKVJ8IULktMN06N0FKCpHCoYsjC4F+Z0NVqdNFoGSTjSiyjzLdnZ2fNqTi2eHKONONKLMPMKLONKLMPQRJGlFxZRoKcJFAYEeIFiRQkUWUeYfef//Ko04soswso40UJAgMw8wosososy0EalnZyjQUGBRQGIFggOWUacWUeYmuadrZziQKKEgQsQLAhQkUJAgMQDghltLO1onp0cpkNInSFMqlYeSEJ5AHsqFdOwy1DA2sRmRJKxdKRfLhfLw5BzUxBTUUzLjk4LjJVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjk4LjJVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7ksRRA8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=";

// 2. Setup the audio tag
const audioTag = document.createElement("audio");
audioTag.controls = false;
audioTag.preload = "auto";
audioTag.loop = true; // looping is usually fine here, but we'll pause it right away
audioTag.src = silenceDataURI;

// 3. Unlock audio on the FIRST user interaction
let isAudioUnlocked = false;

const unlockAudio = () => {
    if (isAudioUnlocked) return;
    
    // Play the silent audio file to bypass the mute switch
    audioTag.play().then(() => {
        // As soon as it plays, we can pause it. The session is now unlocked.
        audioTag.pause();
        isAudioUnlocked = true;
        
        // Remove the event listeners to keep things clean
        document.removeEventListener('touchstart', unlockAudio);
        document.removeEventListener('click', unlockAudio);
    }).catch(err => {
        // If it fails (e.g., browser policies), we'll just quietly ignore it
        console.warn("Audio unlock failed:", err);
    });
};

// Bind to both touch and click to ensure we catch the user's first action
document.addEventListener('touchstart', unlockAudio, { once: true });
document.addEventListener('click', unlockAudio, { once: true });

// ‚îÄ‚îÄ‚îÄ SCREEN WAKE LOCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Prevents iOS/Android from dimming or locking the screen while
// the drone, metronome, or recorder is active.
let wakeLock = null;
async function updateWakeLock() {
    const audioActive = droneState?.running || metroRunning || recorder?.state === 'recording' || tunerRunning;
    if (audioActive && !wakeLock && 'wakeLock' in navigator) {
        try { wakeLock = await navigator.wakeLock.request('screen'); }
        catch(e) { /* permission denied or not supported ‚Äî silently ignore */ }
    } else if (!audioActive && wakeLock) {
        try { wakeLock.release(); } catch(e) {}
        wakeLock = null;
    }
}

// ‚îÄ‚îÄ‚îÄ AUDIO CONTEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let audioCtx, db;
const getCtx = () => {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended' || audioCtx.state === 'interrupted') audioCtx.resume();
    return audioCtx;
};

// When the page becomes visible again after being backgrounded, resume the AudioContext
// and resync audio. iOS suspends (or interrupts) the context when the app is backgrounded.
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState !== 'visible') {
        // iOS kills mic access when backgrounded ‚Äî stop the tuner cleanly
        if (tunerRunning) stopTuner();
        return;
    }
    if (!audioCtx) return;

    audioCtx.resume().then(() => {
        // Null out cached master gain nodes so they are recreated fresh and
        // properly reconnected to the destination after the context resumes.
        droneMaster = null;
        metroMaster = null;

        // Drone: oscillators are killed by the browser when the context is suspended on iOS.
        // Restart them if the drone was running.
        if (droneState.running) {
            stopDrone();
            startDrone();
        }

        // Metronome: nextBeat will be far in the past after a long background gap.
        // Reset it to now so the scheduler doesn't flood with catch-up beats.
        if (metroRunning) {
            clearTimeout(schedTimer);
            pulseIndex = 0;
            nextBeat = audioCtx.currentTime;
            sched();
        }

        // Wake lock is released automatically when the page is hidden; re-acquire it.
        updateWakeLock();
    });
});

// ‚îÄ‚îÄ‚îÄ PERSISTENCE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const PREFS_KEY = 'toolkit_prefs_v2';
function loadPrefs() { try { return JSON.parse(localStorage.getItem(PREFS_KEY)) || {}; } catch { return {}; } }
function savePrefs() {
    try {
        localStorage.setItem(PREFS_KEY, JSON.stringify({
            bpm, meter, metroSound, metroLight,
            metroVolume, clickSound,
            droneRoot: droneState.root,
            droneIntervals: [...droneState.intervals],
            droneTuning: droneState.tuning,
            droneColor: droneState.color,
            droneOctave: droneState.octave,
            droneVolume: droneState.volume,
            refA
        }));
    } catch(e) {}
}

// ‚îÄ‚îÄ‚îÄ INDEXEDDB ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const initDB = () => new Promise(res => {
    const req = indexedDB.open('MusiciansToolkit', 1);
    req.onupgradeneeded = e => e.target.result.createObjectStore('memos', { keyPath: 'id' });
    req.onsuccess = e => { db = e.target.result; res(); };
});

// ‚îÄ‚îÄ‚îÄ DRONE DATA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const noteNames = ["C","C#","D","Eb","E","F","F#","G","Ab","A","Bb","B"];
const droneRatios = [
    {n:"Uni",s:0, r:1,      f:"1/1"},   {n:"m2", s:1,  r:16/15, f:"16/15"},
    {n:"M2", s:2, r:9/8,    f:"9/8"},   {n:"m3", s:3,  r:6/5,   f:"6/5"},
    {n:"M3", s:4, r:5/4,    f:"5/4"},   {n:"P4", s:5,  r:4/3,   f:"4/3"},
    {n:"TT", s:6, r:7/5,    f:"7/5"},   {n:"P5", s:7,  r:3/2,   f:"3/2"},
    {n:"m6", s:8, r:8/5,    f:"8/5"},   {n:"M6", s:9,  r:5/3,   f:"5/3"},
    {n:"m7", s:10,r:16/9,   f:"16/9"},  {n:"M7", s:11, r:15/8,  f:"15/8"},
    {n:"Oct",s:12,r:2,      f:"2/1"}
];

// ‚îÄ‚îÄ‚îÄ DRONE STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const prefs = loadPrefs();
let droneState = {
    root:     prefs.droneRoot     ?? 9,
    intervals:new Set(prefs.droneIntervals ?? [0]),
    tuning:   prefs.droneTuning   ?? 'just',
    color:    prefs.droneColor    ?? 'sine',
    running:  false,
    octave:   prefs.droneOctave   ?? 4,
    volume:   prefs.droneVolume   ?? 0.7
};
let activeOscs = [], droneMaster = null;
let refA = prefs.refA ?? prefs.droneRef ?? 440;

function getDroneMaster() {
    const ctx = getCtx();
    if (!droneMaster || droneMaster.context !== ctx) {
        droneMaster = ctx.createGain();
        droneMaster.gain.value = droneState.volume;
        droneMaster.connect(ctx.destination);
    }
    return droneMaster;
}

function getIntervalLabel() {
    return [...droneState.intervals].sort((a,b)=>a-b)
        .map(s => droneRatios.find(r=>r.s===s).n).join('+');
}

function updateDroneDebug() {
    const rootFreq = (refA * Math.pow(2,(droneState.root-9)/12)) * Math.pow(2,droneState.octave-4);
    let txt = `ROOT: ${noteNames[droneState.root]} @ ${rootFreq.toFixed(2)}Hz\nMODE: ${droneState.tuning.toUpperCase()}\n\n`;
    [...droneState.intervals].sort((a,b)=>a-b).forEach(s => {
        const iv = droneRatios.find(r=>r.s===s);
        const freq = droneState.tuning==='equal' ? rootFreq*Math.pow(2,s/12) : rootFreq*iv.r;
        const ratio = droneState.tuning==='equal' ? `2^(${s}/12)` : `${iv.f} (${iv.r.toFixed(3)})`;
        txt += `${iv.n.padEnd(4)}: ${freq.toFixed(2)}Hz | ${ratio}\n`;
    });
    document.getElementById('debug-console').innerText = txt;
    savePrefs();
}

function startDrone() {
    updateWakeLock();
    const ctx = getCtx();
    const rootFreq = (refA * Math.pow(2,(droneState.root-9)/12)) * Math.pow(2,droneState.octave-4);
    const master = getDroneMaster();
    droneState.intervals.forEach(s => {
        const iv = droneRatios.find(r=>r.s===s);
        const f = droneState.tuning==='equal' ? rootFreq*Math.pow(2,s/12) : rootFreq*iv.r;
        const osc = ctx.createOscillator(), g = ctx.createGain();
        osc.type = droneState.color;
        osc.frequency.setValueAtTime(f, ctx.currentTime);
        g.gain.setValueAtTime(0, ctx.currentTime);
        g.gain.linearRampToValueAtTime(0.15, ctx.currentTime+0.12);
        osc.connect(g).connect(master);
        osc.start();
        activeOscs.push({osc, g});
    });
}

const stopDrone = () => {
    const ctx = getCtx();
    activeOscs.forEach(n => {
        try { n.g.gain.linearRampToValueAtTime(0, ctx.currentTime+0.1); } catch(e){}
        setTimeout(() => { try { n.osc.stop(); } catch(e){} }, 150);
    });
    activeOscs = [];
    updateWakeLock();
};

const droneSync = () => { updateDroneDebug(); if(droneState.running){ stopDrone(); startDrone(); } };

// Build root grid
noteNames.forEach((n,i) => {
    const b = document.createElement('button');
    b.className='btn-toggle'; b.textContent=n;
    if(i===droneState.root) b.classList.add('active');
    b.onclick = () => {
        document.querySelectorAll('#rootGrid .btn-toggle').forEach(x=>x.classList.remove('active'));
        b.classList.add('active'); droneState.root=i; droneSync();
    };
    document.getElementById('rootGrid').appendChild(b);
});

// Build interval grid
droneRatios.forEach(rt => {
    const b = document.createElement('button');
    b.className='btn-toggle'; b.textContent=rt.n;
    if(droneState.intervals.has(rt.s)) b.classList.add('active');
    b.onclick = () => {
        if(droneState.intervals.has(rt.s) && droneState.intervals.size>1) {
            droneState.intervals.delete(rt.s); b.classList.remove('active');
        } else {
            droneState.intervals.add(rt.s); b.classList.add('active');
        }
        droneSync();
    };
    document.getElementById('intervalGrid').appendChild(b);
});

document.getElementById('droneToggle').onclick = function() {
    droneState.running = !droneState.running;
    if(droneState.running){ startDrone(); this.textContent='üéµ Stop Drone'; this.classList.add('is-active'); }
    else { stopDrone(); this.textContent='üéµ Start Drone'; this.classList.remove('is-active'); }
};

document.getElementById('droneClear').onclick = () => {
    droneState.intervals = new Set([0]);
    document.querySelectorAll('#intervalGrid .btn-toggle').forEach((b,i)=>b.classList.toggle('active',i===0));
    droneSync();
};

// Restore saved values
const droneRefVal   = document.getElementById('droneRefVal');
const droneOctaveInput = document.getElementById('droneOctave');
const droneOctaveVal   = document.getElementById('droneOctaveVal');

droneRefVal.textContent = refA;
droneOctaveInput.value = droneState.octave;
droneOctaveVal.textContent = droneState.octave;

document.getElementById('droneRefMinus').onclick = () => {
    refA = Math.max(400, refA - 1);
    droneRefVal.textContent = refA;
    document.getElementById('tunerRefVal').textContent = refA;
    droneSync(); savePrefs();
};
document.getElementById('droneRefPlus').onclick = () => {
    refA = Math.min(480, refA + 1);
    droneRefVal.textContent = refA;
    document.getElementById('tunerRefVal').textContent = refA;
    droneSync(); savePrefs();
};
document.getElementById('droneOctaveMinus').onclick = () => {
    const v = Math.max(1, (parseInt(droneOctaveInput.value)||4) - 1);
    droneOctaveInput.value = v; droneOctaveVal.textContent = v; droneState.octave=v; droneSync();
};
document.getElementById('droneOctavePlus').onclick = () => {
    const v = Math.min(6, (parseInt(droneOctaveInput.value)||4) + 1);
    droneOctaveInput.value = v; droneOctaveVal.textContent = v; droneState.octave=v; droneSync();
};

// Volume slider
document.getElementById('droneVolume').value = droneState.volume;
document.getElementById('droneVolume').oninput = e => {
    droneState.volume = parseFloat(e.target.value);
    if(droneMaster) droneMaster.gain.value = droneState.volume;
    savePrefs();
};

// Tuning + wave switches ‚Äî restore saved state
['tuningSwitch','colorSwitch'].forEach(id => {
    const key = id==='tuningSwitch' ? 'tuning' : 'color';
    document.querySelectorAll(`#${id} button`).forEach(b => b.classList.toggle('active', b.dataset.val===droneState[key]));
    document.getElementById(id).onclick = e => {
        if(e.target.tagName!=='BUTTON') return;
        document.querySelectorAll(`#${id} button`).forEach(b=>b.classList.remove('active'));
        e.target.classList.add('active');
        droneState[key]=e.target.dataset.val; droneSync();
    };
});

// Details toggle
const detailsBtn = document.getElementById('detailsToggle');
const debugEl    = document.getElementById('debug-console');
detailsBtn.onclick = () => {
    const open = debugEl.style.display !== 'none';
    debugEl.style.display = open ? 'none' : 'block';
    detailsBtn.textContent = open ? 'üî¨ Show Details' : 'üî¨ Hide Details';
};

// ‚îÄ‚îÄ‚îÄ METRONOME STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let bpm         = prefs.bpm         ?? 120;
let metroSound  = prefs.metroSound  ?? true;
let metroLight  = prefs.metroLight  ?? true;
let metroVolume = prefs.metroVolume ?? 0.7;
let clickSound  = prefs.clickSound  ?? 'clave';
const DEFAULT_METER = { groups:[1,1,1,1], denom:4, subdivision:1 };
let meter = Object.assign({}, DEFAULT_METER, prefs.meter ?? {});
meter.groups = Array.isArray(meter.groups) ? meter.groups : DEFAULT_METER.groups;
let metroRunning=false, nextBeat=0, schedTimer, pulseIndex=0;
let schedPulses=[], totalPulses=0;
let metroMaster = null;

function getMetroMaster() {
    const ctx = getCtx();
    if (!metroMaster || metroMaster.context !== ctx) {
        metroMaster = ctx.createGain();
        metroMaster.gain.value = metroVolume;
        metroMaster.connect(ctx.destination);
    }
    return metroMaster;
}

const bpmDisplay = document.getElementById('bpm-display');
const bpmInput   = document.getElementById('bpm-input');
const metroCard  = document.getElementById('metro-card');
const wheelEl    = document.getElementById('wheel');

const updateBPMDisplay = v => {
    bpm = Math.min(Math.max(v,40),280);
    bpmDisplay.textContent = bpm;
    bpmInput.value = bpm;
    wheelEl.style.transform = `rotate(${bpm*1.5}deg)`;
};
const updateBPM = v => { updateBPMDisplay(v); buildSchedule(); savePrefs(); };

bpmDisplay.onclick = () => { bpmDisplay.style.display='none'; bpmInput.style.display='block'; bpmInput.focus(); };
bpmInput.onblur   = () => { updateBPM(parseInt(bpmInput.value)||120); bpmInput.style.display='none'; bpmDisplay.style.display='block'; };
bpmInput.onkeydown = e => { if(e.key==='Enter') bpmInput.blur(); };
document.getElementById('bpmMinus').onclick = () => updateBPM(bpm-1);
document.getElementById('bpmPlus').onclick  = () => updateBPM(bpm+1);

// Metro volume slider
document.getElementById('metroVolume').value = metroVolume;
document.getElementById('metroVolume').oninput = e => {
    metroVolume = parseFloat(e.target.value);
    if(metroMaster) metroMaster.gain.value = metroVolume;
    savePrefs();
};

// ‚îÄ‚îÄ‚îÄ TIME SIGNATURE TEXT INPUT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function meterToString(m) {
    const n = m.groups.reduce((a,b)=>a+b, 0);
    return `${n}/${m.denom}`;
}

function parseTsInput(str) {
    const m = str.trim().match(/^(\d+)\s*\/\s*(\d+)$/);
    if (!m) return null;
    const n = parseInt(m[1]), d = parseInt(m[2]);
    if (n < 1 || n > 32 || d < 1 || d > 64) return null;
    return { groups: Array(n).fill(1), denom: d };
}

const tsInput = document.getElementById('tsInput');
tsInput.value = meterToString(meter);

function commitTsInput() {
    const parsed = parseTsInput(tsInput.value);
    if (parsed) {
        tsInput.classList.remove('error');
        tsInput.value = `${parsed.groups.length}/${parsed.denom}`;
        meter.groups = parsed.groups;
        meter.denom  = parsed.denom;
        applyMeterChange();
    } else {
        tsInput.classList.add('error');
    }
}

tsInput.addEventListener('blur', commitTsInput);
tsInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') { tsInput.blur(); }
    if (e.key === 'Escape') { tsInput.value = meterToString(meter); tsInput.classList.remove('error'); tsInput.blur(); }
});
tsInput.addEventListener('input', () => {
    if (tsInput.classList.contains('error') && parseTsInput(tsInput.value)) {
        tsInput.classList.remove('error');
    }
});

// ‚îÄ‚îÄ‚îÄ SUBDIVISION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.querySelectorAll('#subdivCtrl button').forEach(b=>
    b.classList.toggle('active', parseInt(b.dataset.val)===meter.subdivision));
document.getElementById('subdivCtrl').onclick = e => {
    if(e.target.tagName!=='BUTTON') return;
    document.querySelectorAll('#subdivCtrl button').forEach(b=>b.classList.remove('active'));
    e.target.classList.add('active');
    meter.subdivision=parseInt(e.target.dataset.val);
    applyMeterChange();
};

// ‚îÄ‚îÄ‚îÄ CLICK SOUND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.querySelectorAll('#clickSoundCtrl button').forEach(b=>b.classList.toggle('active',b.dataset.val===clickSound));
document.getElementById('clickSoundCtrl').onclick = e => {
    if(e.target.tagName!=='BUTTON') return;
    document.querySelectorAll('#clickSoundCtrl button').forEach(b=>b.classList.remove('active'));
    e.target.classList.add('active');
    clickSound=e.target.dataset.val; savePrefs();
};

// ‚îÄ‚îÄ‚îÄ CLICK SOUNDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function playClave(atTime, isAccent) {
    const ctx = getCtx(), SR = ctx.sampleRate, out = getMetroMaster();
    const vol = isAccent ? 1.0 : 0.60, freq = isAccent ? 2750 : 2450;
    const body = ctx.createOscillator(), bG = ctx.createGain();
    body.type='sine';
    body.frequency.setValueAtTime(freq, atTime);
    body.frequency.exponentialRampToValueAtTime(freq*0.87, atTime+0.045);
    bG.gain.setValueAtTime(vol*0.6, atTime);
    bG.gain.exponentialRampToValueAtTime(0.001, atTime+0.045);
    body.connect(bG).connect(out); body.start(atTime); body.stop(atTime+0.055);

    const cLen=Math.floor(SR*0.013), nbuf=ctx.createBuffer(1,cLen,SR);
    const nd=nbuf.getChannelData(0); for(let i=0;i<cLen;i++) nd[i]=Math.random()*2-1;
    const noise=ctx.createBufferSource(); noise.buffer=nbuf;
    const bp=ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=3100; bp.Q.value=1.3;
    const cG=ctx.createGain();
    cG.gain.setValueAtTime(vol*0.48, atTime); cG.gain.exponentialRampToValueAtTime(0.001, atTime+0.013);
    noise.connect(bp).connect(cG).connect(out); noise.start(atTime); noise.stop(atTime+0.016);

    const res=ctx.createOscillator(), rG=ctx.createGain();
    res.type='sine'; res.frequency.setValueAtTime(3700, atTime);
    rG.gain.setValueAtTime(vol*0.18, atTime); rG.gain.exponentialRampToValueAtTime(0.001, atTime+0.022);
    res.connect(rG).connect(out); res.start(atTime); res.stop(atTime+0.028);
}

function playClick(atTime, isAccent) {
    // Mechanical metronome click: sharp sine with very fast decay
    const ctx = getCtx(), out = getMetroMaster();
    const vol = isAccent ? 1.0 : 0.65, freq = isAccent ? 1200 : 900;
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.type = 'square';
    o.frequency.setValueAtTime(freq, atTime);
    o.frequency.exponentialRampToValueAtTime(freq*0.5, atTime+0.018);
    g.gain.setValueAtTime(vol*0.4, atTime);
    g.gain.exponentialRampToValueAtTime(0.001, atTime+0.018);
    const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2200;
    o.connect(lp).connect(g).connect(out); o.start(atTime); o.stop(atTime+0.022);
}

function playRim(atTime, isAccent) {
    // Snare rim shot: noise filtered to midrange with sharp transient
    const ctx = getCtx(), SR = ctx.sampleRate, out = getMetroMaster();
    const vol = isAccent ? 1.0 : 0.6;
    const dur = isAccent ? 0.055 : 0.04;
    const len = Math.floor(SR * dur);
    const buf = ctx.createBuffer(1, len, SR);
    const d = buf.getChannelData(0);
    for(let i=0;i<len;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/(len*0.3));
    const src = ctx.createBufferSource(); src.buffer = buf;
    const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = isAccent ? 900 : 700; hp.Q.value=2;
    const bp = ctx.createBiquadFilter(); bp.type='peaking'; bp.frequency.value=2500; bp.gain.value=8;
    const g = ctx.createGain(); g.gain.setValueAtTime(vol*0.9, atTime);
    src.connect(hp).connect(bp).connect(g).connect(out);
    src.start(atTime); src.stop(atTime+dur+0.01);
    // Add a ping for the accent
    if(isAccent) {
        const ping=ctx.createOscillator(), pg=ctx.createGain();
        ping.type='sine'; ping.frequency.setValueAtTime(1600, atTime);
        pg.gain.setValueAtTime(0.3, atTime); pg.gain.exponentialRampToValueAtTime(0.001, atTime+0.03);
        ping.connect(pg).connect(out); ping.start(atTime); ping.stop(atTime+0.035);
    }
}

function playCowbell(atTime, isAccent) {
    // Classic cowbell: two detuned square waves + metal resonance
    const ctx = getCtx(), out = getMetroMaster();
    const vol = isAccent ? 1.0 : 0.62;
    const dur = isAccent ? 0.28 : 0.18;
    [[562, 1], [845, 0.6]].forEach(([f, fvol]) => {
        const o=ctx.createOscillator(), g=ctx.createGain();
        o.type='square'; o.frequency.value=f;
        const bp=ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=f*1.4; bp.Q.value=0.8;
        g.gain.setValueAtTime(vol*fvol*0.3, atTime);
        g.gain.exponentialRampToValueAtTime(0.001, atTime+dur);
        o.connect(bp).connect(g).connect(out); o.start(atTime); o.stop(atTime+dur+0.01);
    });
    // Metal click transient
    const o2=ctx.createOscillator(), g2=ctx.createGain();
    o2.type='triangle'; o2.frequency.setValueAtTime(3500, atTime); o2.frequency.exponentialRampToValueAtTime(1800, atTime+0.015);
    g2.gain.setValueAtTime(vol*0.5, atTime); g2.gain.exponentialRampToValueAtTime(0.001, atTime+0.015);
    o2.connect(g2).connect(out); o2.start(atTime); o2.stop(atTime+0.02);
}

function playBeat(atTime, isAccent) {
    if(clickSound==='clave')   playClave(atTime, isAccent);
    else if(clickSound==='click') playClick(atTime, isAccent);
    else if(clickSound==='rim')   playRim(atTime, isAccent);
    else if(clickSound==='cowbell') playCowbell(atTime, isAccent);
}

function playSubdiv(atTime) {
    const ctx = getCtx(), out = getMetroMaster();
    const o=ctx.createOscillator(), g=ctx.createGain();
    o.type='sine'; o.frequency.value=1900;
    g.gain.setValueAtTime(0.11, atTime);
    g.gain.exponentialRampToValueAtTime(0.001, atTime+0.02);
    o.connect(g).connect(out);
    o.start(atTime); o.stop(atTime+0.025);
}

const viewportFlash = document.getElementById('viewport-flash');
function triggerFlash(atTime, isAccent) {
    const delay = Math.max(0, (atTime-getCtx().currentTime)*1000);
    const dur = isAccent ? 130 : 80;
    setTimeout(() => {
        wheelEl.classList.add('beat-flash');
        metroCard.classList.add('beat-flash');
        viewportFlash.classList.add('beat-flash');
        if(isAccent) viewportFlash.classList.add('accent');
        setTimeout(() => {
            wheelEl.classList.remove('beat-flash');
            metroCard.classList.remove('beat-flash');
            viewportFlash.classList.remove('beat-flash');
            viewportFlash.classList.remove('accent');
        }, dur);
    }, delay);
}

function buildSchedule() {
    schedPulses = [];
    // Each beat takes 60/bpm seconds; the denominator is notation-only and doesn't affect timing
    const beatSec = 60 / bpm;
    meter.groups.forEach(groupSize => {
        const groupDurSec = groupSize * beatSec;
        const subDur = groupDurSec / meter.subdivision;
        for(let s=0; s<meter.subdivision; s++) {
            schedPulses.push({ isGroupBeat: s===0, subDur });
        }
    });
    totalPulses = schedPulses.length;
}

function applyMeterChange() {
    buildSchedule();
    if(metroRunning) { pulseIndex=0; nextBeat=getCtx().currentTime; }
    savePrefs();
}

function sched() {
    const ctx = getCtx();
    while(nextBeat < ctx.currentTime+0.1) {
        const pulse = schedPulses[pulseIndex % totalPulses];
        const isDownbeat = (pulseIndex % totalPulses === 0);
        if(metroSound) {
            if(pulse.isGroupBeat) playBeat(nextBeat, isDownbeat);
            else                  playSubdiv(nextBeat);
        }
        if(metroLight && pulse.isGroupBeat) triggerFlash(nextBeat, isDownbeat);
        pulseIndex++;
        nextBeat += pulse.subDur;
    }
    schedTimer = setTimeout(sched, 25);
}

function updateMetroBtn() {
    const btn=document.getElementById('metroStartBtn');
    if(!btn) return;
    if(metroRunning){ btn.innerHTML='‚ñ†<br>Stop'; btn.classList.add('is-active'); }
    else { btn.innerHTML='‚ñ∂<br>Start'; btn.classList.remove('is-active'); }
}
function startMetro() {
    if(metroRunning) return;
    metroRunning=true; pulseIndex=0;
    buildSchedule();
    nextBeat=getCtx().currentTime; sched();
    updateMetroBtn();
    updateWakeLock();
}
function stopMetro() {
    if(!metroRunning) return;
    metroRunning=false; clearTimeout(schedTimer);
    wheelEl.classList.remove('beat-flash');
    metroCard.classList.remove('beat-flash');
    viewportFlash.classList.remove('beat-flash');
    viewportFlash.classList.remove('accent');
    updateMetroBtn();
    updateWakeLock();
}
// Restore output toggle states
if(metroSound) document.getElementById('soundToggle').classList.add('active');
if(metroLight) document.getElementById('lightToggle').classList.add('active');

document.getElementById('soundToggle').onclick = function() {
    if(metroSound && !metroLight) return; // can't turn off last active mode
    metroSound=!metroSound; this.classList.toggle('active',metroSound); savePrefs();
};
document.getElementById('lightToggle').onclick = function() {
    if(metroLight && !metroSound) return; // can't turn off last active mode
    metroLight=!metroLight; this.classList.toggle('active',metroLight); savePrefs();
};
document.getElementById('metroStartBtn').onclick = function() {
    if(metroRunning) { stopMetro(); }
    else { startMetro(); }
    savePrefs();
};

// Tap tempo
let tapTimes=[], tapResetTimer=null;
document.getElementById('tapBtn').onclick = () => {
    const now=performance.now();
    clearTimeout(tapResetTimer);
    if(tapTimes.length && now-tapTimes[tapTimes.length-1]>2000) tapTimes=[];
    tapTimes.push(now);
    if(tapTimes.length>=2) {
        const gaps=tapTimes.slice(1).map((t,i)=>t-tapTimes[i]);
        updateBPM(Math.round(60000/(gaps.reduce((a,b)=>a+b)/gaps.length)));
        if(metroRunning){ clearTimeout(schedTimer); beatCount=0; nextBeat=getCtx().currentTime; sched(); }
    }
    if(tapTimes.length>8) tapTimes=tapTimes.slice(-8);
    tapResetTimer=setTimeout(()=>{ tapTimes=[]; },2000);
};

// Wheel drag
(function(){
    const outer=wheelEl.parentElement;
    let dragging=false, lastAngle=0, fracBpm=0;
    const getAngle=e=>{
        const r=outer.getBoundingClientRect();
        const px=e.touches?e.touches[0].clientX:e.clientX;
        const py=e.touches?e.touches[0].clientY:e.clientY;
        return Math.atan2(py-(r.top+r.height/2), px-(r.left+r.width/2))*(180/Math.PI);
    };
    const onMove=e=>{
        if(!dragging)return;
        const angle=getAngle(e);
        let d=angle-lastAngle; lastAngle=angle;
        if(d>180)d-=360; if(d<-180)d+=360;
        fracBpm+=d/1.5;
        const whole=Math.trunc(fracBpm);
        if(whole!==0){ updateBPMDisplay(bpm+whole); fracBpm-=whole; }
    };
    const onEnd=()=>{
        if(!dragging)return;
        dragging=false; wheelEl.style.cursor='grab';
        fracBpm=0;
        if(metroRunning){ buildSchedule(); pulseIndex=0; nextBeat=getCtx().currentTime; }
        savePrefs();
    };
    wheelEl.addEventListener('mousedown',e=>{ e.preventDefault(); dragging=true; lastAngle=getAngle(e); fracBpm=0; wheelEl.style.cursor='grabbing'; });
    window.addEventListener('mousemove',onMove);
    window.addEventListener('mouseup',onEnd);
    wheelEl.addEventListener('touchstart',e=>{ e.preventDefault(); dragging=true; lastAngle=getAngle(e); fracBpm=0; },{passive:false});
    window.addEventListener('touchmove',e=>{ if(!dragging)return; e.preventDefault(); onMove(e); },{passive:false});
    window.addEventListener('touchend',onEnd);
})();

// ‚îÄ‚îÄ‚îÄ RECORDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let recorder, chunks=[], liveAnimFrame=null, liveAnalyser=null, memoUrls=[];

// ‚îÄ‚îÄ Pick the best supported MIME type for this browser ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// iOS Safari only supports audio/mp4; Chrome/Firefox prefer audio/webm
function getSupportedMimeType() {
    const types = ['audio/webm;codecs=opus', 'audio/webm', 'audio/mp4', 'audio/ogg;codecs=opus', ''];
    return types.find(t => !t || MediaRecorder.isTypeSupported(t)) || '';
}

function mimeToExt(mime) {
    if(mime.includes('mp4')) return 'mp4';
    if(mime.includes('ogg')) return 'ogg';
    return 'webm';
}

function drawLiveWaveform() {
    const canvas=document.getElementById('liveWaveform');
    const c2d=canvas.getContext('2d');
    canvas.width=canvas.offsetWidth;
    const buf=new Uint8Array(liveAnalyser.fftSize);
    (function draw(){
        if(!liveAnalyser) return;
        liveAnimFrame=requestAnimationFrame(draw);
        liveAnalyser.getByteTimeDomainData(buf);
        c2d.clearRect(0,0,canvas.width,canvas.height);
        c2d.strokeStyle='#22c55e'; c2d.lineWidth=2;
        c2d.beginPath();
        const sw=canvas.width/buf.length; let x=0;
        for(let i=0;i<buf.length;i++){
            const y=(buf[i]/128)*canvas.height/2;
            i===0?c2d.moveTo(x,y):c2d.lineTo(x,y); x+=sw;
        }
        c2d.lineTo(canvas.width,canvas.height/2); c2d.stroke();
    })();
}

function stopLiveWaveform() {
    if(liveAnimFrame){ cancelAnimationFrame(liveAnimFrame); liveAnimFrame=null; }
    liveAnalyser=null;
    const canvas=document.getElementById('liveWaveform');
    canvas.style.display='none';
    canvas.getContext('2d').clearRect(0,0,canvas.width,canvas.height);
}

function getAutoName() {
    const now=new Date();
    const d=now.toLocaleDateString([],{month:'short',day:'numeric'});
    const t=now.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});
    return `${d} ${t}`;
}

document.getElementById('recordToggle').onclick = async function() {
    if(recorder?.state==='recording') {
        recorder.stop(); stopLiveWaveform();
        this.textContent='üéôÔ∏è Start Recording'; this.classList.remove('is-active');
        document.getElementById('rec-status').textContent='';
        updateWakeLock();
        return;
    }
    const stream=await navigator.mediaDevices.getUserMedia({audio:true});
    const autoName=getAutoName();
    const mimeType=getSupportedMimeType();
    const recOpts=mimeType ? {mimeType} : {};
    recorder=new MediaRecorder(stream, recOpts); chunks=[];
    recorder.ondataavailable=e=>{ if(e.data.size>0) chunks.push(e.data); };
    recorder.onstop=()=>{
        stream.getTracks().forEach(t=>t.stop());
        const actualMime=recorder.mimeType||mimeType||'audio/webm';
        const blob=new Blob(chunks,{type:actualMime});
        const item={id:Date.now().toString(), blob, mimeType:actualMime, ts:Date.now(), name:autoName};
        const tx=db.transaction('memos','readwrite');
        tx.objectStore('memos').put(item);
        tx.oncomplete=renderMemos;
    };
    // iOS: resume AudioContext before creating source (requires user gesture ‚Äî we're inside one)
    const ctx=getCtx();
    liveAnalyser=ctx.createAnalyser(); liveAnalyser.fftSize=2048;
    ctx.createMediaStreamSource(stream).connect(liveAnalyser);
    const canvas=document.getElementById('liveWaveform');
    canvas.style.display='block'; drawLiveWaveform();
    // timeslice=250ms ensures data flows on iOS (which may not fire ondataavailable without it)
    recorder.start(250);
    this.textContent='‚èπÔ∏è Stop Recording'; this.classList.add('is-active');
    document.getElementById('rec-status').textContent='‚óè Recording...';
    updateWakeLock();
};

function saveMemoName(m, name) {
    m.name=name.trim()||m.name;
    const tx=db.transaction('memos','readwrite');
    tx.objectStore('memos').put(m);
}

function renderMemos() {
    memoUrls.forEach(u => URL.revokeObjectURL(u)); memoUrls=[];
    const list=document.getElementById('memoList'); list.innerHTML='';
    db.transaction('memos').objectStore('memos').getAll().onsuccess=e=>{
        e.target.result.sort((a,b)=>b.ts-a.ts).forEach(m=>{
            const mime=m.mimeType||(m.blob&&m.blob.type)||'audio/webm';
            const ext=mimeToExt(mime);
            // Create a correctly-typed blob URL ‚Äî critical for iOS to decode it
            const typedBlob=new Blob([m.blob],{type:mime});
            const url=URL.createObjectURL(typedBlob); memoUrls.push(url);
            const label=m.name||`Memo ‚Äî ${new Date(m.ts).toLocaleString()}`;
            const d=document.createElement('div'); d.className='recording-item';
            d.innerHTML=`
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
                    <strong id="lbl-${m.id}" style="flex:1;cursor:text;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="Click to rename">${label}</strong>
                    <input id="inp-${m.id}" type="text"
                        style="display:none;flex:1;background:var(--bg);border:1px solid var(--primary);color:var(--text);border-radius:6px;padding:4px 8px;font-size:0.95rem;font-weight:700;outline:none;min-width:0;">
                    <button class="secondary" id="ren-${m.id}" style="padding:0.6rem 0.8rem;font-size:0.85rem;flex-shrink:0;min-width:44px;min-height:44px;">‚úèÔ∏è</button>
                </div>
                <div id="w-${m.id}" class="wf-box"></div>
                <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
                    <button class="main-action" id="p-${m.id}">‚ñ∂ Play</button>
                    <button class="secondary" id="dl-${m.id}">‚¨á Export</button>
                    <button class="secondary" onclick="deleteMemo('${m.id}')">üóë Delete</button>
                </div>`;
            list.appendChild(d);

            // Use MediaElement backend: lets the browser's native <audio> handle decoding,
            // which is the only reliable approach on iOS Safari for blob URLs.
            const ws=WaveSurfer.create({
                container:`#w-${m.id}`,
                waveColor:'#475569',
                progressColor:'#22c55e',
                backend:'MediaElement',
                url
            });
            const pb=document.getElementById(`p-${m.id}`);
            ws.on('play',()=>pb.textContent='‚è∏ Pause');
            ws.on('pause',()=>pb.textContent='‚ñ∂ Play');
            ws.on('finish',()=>pb.textContent='‚ñ∂ Play');
            // iOS: playPause must be triggered directly from user tap (already is via onclick)
            pb.onclick=()=>ws.playPause();

            document.getElementById(`dl-${m.id}`).onclick=()=>{
                const a=document.createElement('a'); a.href=url;
                a.download=`${(m.name||'memo').replace(/[^\w\s\-]/g,'_').trim()}.${ext}`;
                a.click();
            };

            const lbl=document.getElementById(`lbl-${m.id}`);
            const inp=document.getElementById(`inp-${m.id}`);
            const ren=document.getElementById(`ren-${m.id}`);
            let renaming=false;

            function enterRename() {
                renaming=true; inp.value=lbl.textContent;
                lbl.style.display='none'; inp.style.display='block';
                ren.textContent='‚úì'; inp.focus(); inp.select();
            }
            function commitRename() {
                if(!renaming) return; renaming=false;
                const n=inp.value.trim()||lbl.textContent;
                lbl.textContent=n; lbl.style.display='';
                inp.style.display='none'; ren.textContent='‚úèÔ∏è';
                saveMemoName(m,n);
            }
            ren.onclick=()=>renaming?commitRename():enterRename();
            lbl.onclick=enterRename;
            inp.onblur=()=>setTimeout(commitRename,80);
            inp.onkeydown=e=>{ if(e.key==='Enter')commitRename(); if(e.key==='Escape'){renaming=false;inp.style.display='none';lbl.style.display='';ren.textContent='‚úèÔ∏è';} };
        });
    };
}

window.deleteMemo = id => {
    if(!confirm('Delete this memo?')) return;
    const tx=db.transaction('memos','readwrite');
    tx.objectStore('memos').delete(id);
    tx.oncomplete=renderMemos;
};

// ‚îÄ‚îÄ‚îÄ CHROMATIC TUNER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const TUNER_NOTES = ['C','C‚ôØ','D','E‚ô≠','E','F','F‚ôØ','G','A‚ô≠','A','B‚ô≠','B'];
const TUNER_BUF_SIZE  = 8;   // rolling median window (~133 ms @ 60 fps)
const TUNER_NOTE_HOLD = 3;   // consecutive agreeing medians before note label switches
let tunerRunning  = false;
let tunerStream   = null;
let tunerSource   = null;
let tunerAnalyser = null;
let tunerRafId    = null;
let tunerFreqBuf  = [];      // raw Hz rolling buffer
let tunerLastMidi = null;    // midi of currently displayed note
let tunerNoteCandidateMidi  = null;
let tunerNoteCandidateCount = 0;

function tunerDetectPitch(analyser, sampleRate) {
    const bufLen = analyser.fftSize;
    const buf = new Float32Array(bufLen);
    analyser.getFloatTimeDomainData(buf);

    // RMS silence gate
    let rms = 0;
    for (let i = 0; i < bufLen; i++) rms += buf[i] * buf[i];
    if (Math.sqrt(rms / bufLen) < 0.01) return null;

    // Lag range: 60 Hz ‚Äì 2000 Hz
    const minLag = Math.floor(sampleRate / 2000);
    const maxLag = Math.floor(sampleRate / 60);

    // Normalized autocorrelation (NSDF).
    // Strategy: compute all NSDF values, find the global maximum, then take the
    // FIRST local maximum that is at least 80% of that global max. This correctly
    // picks the fundamental period: the 2nd harmonic produces a larger NSDF peak
    // at 2√ó the lag, but the fundamental has the first significant peak.
    const nsdfVals = new Float32Array(maxLag + 1);
    for (let lag = minLag; lag <= maxLag; lag++) {
        let corr = 0, norm = 0;
        for (let i = 0; i < bufLen - lag; i++) {
            corr += buf[i] * buf[i + lag];
            norm += buf[i] * buf[i] + buf[i + lag] * buf[i + lag];
        }
        nsdfVals[lag] = norm > 0 ? (2 * corr / norm) : 0;
    }
    // Find global max
    let globalMax = 0;
    for (let lag = minLag; lag <= maxLag; lag++) if (nsdfVals[lag] > globalMax) globalMax = nsdfVals[lag];
    if (globalMax < 0.75) return null; // reject low-confidence / silent frames

    // Find the first local maximum >= 80% of globalMax (the fundamental)
    const threshold = globalMax * 0.8;
    let bestLag = -1;
    for (let lag = minLag + 1; lag < maxLag; lag++) {
        if (nsdfVals[lag] >= threshold &&
            nsdfVals[lag] >= nsdfVals[lag - 1] &&
            nsdfVals[lag] >= nsdfVals[lag + 1]) {
            bestLag = lag;
            break;
        }
    }
    if (bestLag === -1) return null;

    // Parabolic interpolation using the same NSDF values used to find the peak,
    // so the interpolated offset is consistent with how bestLag was selected.
    const y1 = nsdfVals[bestLag - 1];
    const y2 = nsdfVals[bestLag];
    const y3 = nsdfVals[bestLag + 1];
    const denom = 2 * (2 * y2 - y1 - y3);
    const refined = denom !== 0 ? bestLag + (y1 - y3) / denom : bestLag;
    return sampleRate / refined;
}

function tunerFreqToNoteInfo(freq, overrideMidi = null) {
    const midi       = overrideMidi ?? Math.round(69 + 12 * Math.log2(freq / refA));
    const noteName   = TUNER_NOTES[((midi % 12) + 12) % 12];
    const octave     = Math.floor(midi / 12) - 1;
    const targetFreq = refA * Math.pow(2, (midi - 69) / 12);
    const cents      = 1200 * Math.log2(freq / targetFreq);
    return { noteName, octave, cents, midi };
}

function tunerUpdateDisplay(freq, lockedMidi = null) {
    const nameEl   = document.getElementById('tunerNoteName');
    const centsEl  = document.getElementById('tunerCentsDisplay');
    const fillEl   = document.getElementById('tunerMeterFill');

    if (freq === null) {
        nameEl.innerHTML = '‚Äî';
        centsEl.textContent = '';
        centsEl.className = 'tuner-cents';
        fillEl.style.width = '0%';
        fillEl.style.left  = '50%';
        fillEl.className = 'tuner-meter-fill';
        return;
    }

    const { noteName, octave, cents } = tunerFreqToNoteInfo(freq, lockedMidi);

    // Note name: letter + optional accidental as <sup> + octave as <sub>
    const letter     = noteName.replace(/[‚ôØ‚ô≠]/g, '');
    const accidental = noteName.match(/[‚ôØ‚ô≠]/)?.[0] ?? '';
    nameEl.innerHTML = `${letter}${accidental ? `<sup>${accidental}</sup>` : ''}<sub>${octave}</sub>`;

    // Cents display
    const cr = Math.round(cents);
    centsEl.textContent = cr >= 0 ? `+${cr}¬¢` : `${cr}¬¢`;

    // Colour class
    const abs = Math.abs(cents);
    const col = abs <= 5 ? 'in-tune' : abs <= 20 ? 'near-tune' : 'out-tune';
    centsEl.className = `tuner-cents ${col}`;
    fillEl.className  = `tuner-meter-fill ${col}`;

    // Meter fill: centre at 50%, fill extends toward deviation
    const clamped = Math.max(-50, Math.min(50, cents));
    const pct     = clamped / 100 * 100; // -50 to +50 as percentage of track width
    if (cents >= 0) {
        fillEl.style.left  = '50%';
        fillEl.style.width = `${pct}%`;
    } else {
        fillEl.style.left  = `${50 + pct}%`;
        fillEl.style.width = `${-pct}%`;
    }
}

function tunerTick() {
    if (!tunerRunning || !tunerAnalyser) return;
    const raw = tunerDetectPitch(tunerAnalyser, getCtx().sampleRate);

    if (raw === null) {
        // Silence: flush buffer and clear display
        tunerFreqBuf = [];
        tunerLastMidi = null;
        tunerNoteCandidateMidi = null;
        tunerNoteCandidateCount = 0;
        tunerUpdateDisplay(null);
    } else {
        // Accumulate into rolling buffer
        tunerFreqBuf.push(raw);
        if (tunerFreqBuf.length > TUNER_BUF_SIZE) tunerFreqBuf.shift();

        // Wait for half the buffer to fill before showing anything
        if (tunerFreqBuf.length >= Math.ceil(TUNER_BUF_SIZE / 2)) {
            const sorted = [...tunerFreqBuf].sort((a, b) => a - b);
            const median = sorted[Math.floor(sorted.length / 2)];

            // Hysteresis: only commit to a new note after TUNER_NOTE_HOLD confirmations
            const { midi } = tunerFreqToNoteInfo(median);
            if (tunerLastMidi === null) {
                // First lock ‚Äî accept immediately
                tunerLastMidi = midi;
            } else if (midi !== tunerLastMidi) {
                if (midi === tunerNoteCandidateMidi) {
                    tunerNoteCandidateCount++;
                    if (tunerNoteCandidateCount >= TUNER_NOTE_HOLD) {
                        tunerLastMidi = midi;
                        tunerNoteCandidateMidi = null;
                        tunerNoteCandidateCount = 0;
                    }
                } else {
                    tunerNoteCandidateMidi = midi;
                    tunerNoteCandidateCount = 1;
                }
            }

            tunerUpdateDisplay(median, tunerLastMidi);
        }
    }

    tunerRafId = requestAnimationFrame(tunerTick);
}

function tunerUpdateBtn() {
    const btn = document.getElementById('tunerToggle');
    btn.textContent = tunerRunning ? '‚èπ Stop Tuner' : 'üé§ Start Tuner';
    btn.classList.toggle('is-active', tunerRunning);
}

async function startTuner() {
    const statusEl = document.getElementById('tunerStatus');
    statusEl.textContent = 'Requesting microphone‚Ä¶';
    statusEl.className   = 'tuner-status';
    try {
        tunerStream = await navigator.mediaDevices.getUserMedia({
            audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
        });
    } catch (err) {
        statusEl.textContent = err.name === 'NotAllowedError'
            ? 'Microphone access denied. Please allow mic access and try again.'
            : `Microphone error: ${err.message}`;
        statusEl.className = 'tuner-status error';
        tunerRunning = false;
        tunerUpdateBtn();
        return;
    }
    const ctx      = getCtx();
    tunerSource    = ctx.createMediaStreamSource(tunerStream);
    tunerAnalyser  = ctx.createAnalyser();
    tunerAnalyser.fftSize = 4096;
    tunerAnalyser.smoothingTimeConstant = 0;
    tunerSource.connect(tunerAnalyser);
    // Not connected to ctx.destination ‚Äî no audio passthrough / feedback
    statusEl.textContent = '';
    tunerRunning = true;
    tunerUpdateBtn();
    tunerTick();
    updateWakeLock();
}

function stopTuner() {
    tunerRunning = false;
    if (tunerRafId)    { cancelAnimationFrame(tunerRafId); tunerRafId = null; }
    if (tunerSource)   { try { tunerSource.disconnect(); }   catch(e) {} tunerSource = null; }
    if (tunerAnalyser) { try { tunerAnalyser.disconnect(); } catch(e) {} tunerAnalyser = null; }
    if (tunerStream)   { tunerStream.getTracks().forEach(t => t.stop()); tunerStream = null; }
    tunerFreqBuf = [];
    tunerLastMidi = null;
    tunerNoteCandidateMidi = null;
    tunerNoteCandidateCount = 0;
    tunerUpdateDisplay(null);
    tunerUpdateBtn();
    document.getElementById('tunerStatus').textContent = '';
    document.getElementById('tunerStatus').className   = 'tuner-status';
    updateWakeLock();
}

// Wire up tuner buttons
document.getElementById('tunerToggle').onclick = () => {
    tunerRunning ? stopTuner() : startTuner();
};

// Tuner A Ref stepper ‚Äî syncs shared refA and drone display
document.getElementById('tunerRefVal').textContent = refA;
document.getElementById('tunerRefMinus').onclick = () => {
    refA = Math.max(400, refA - 1);
    document.getElementById('tunerRefVal').textContent  = refA;
    document.getElementById('droneRefVal').textContent  = refA;
    droneSync(); savePrefs();
};
document.getElementById('tunerRefPlus').onclick = () => {
    refA = Math.min(480, refA + 1);
    document.getElementById('tunerRefVal').textContent  = refA;
    document.getElementById('droneRefVal').textContent  = refA;
    droneSync(); savePrefs();
};

// ‚îÄ‚îÄ‚îÄ MUSICAL DICTIONARY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function normStr(s) {
    return s.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
}
function fuzzyScore(haystack, needle) {
    if (haystack.includes(needle)) return 2 + 1 / (haystack.indexOf(needle) + 1);
    let hi = 0;
    for (let i = 0; i < needle.length; i++) {
        const idx = haystack.indexOf(needle[i], hi);
        if (idx === -1) return 0;
        hi = idx + 1;
    }
    return 0.5;
}
function dictItemHTML(e) {
    return `<div class="dict-item">
            <span class="dict-term">${e.term}</span>
            <span class="dict-lang">${e.lang}</span>
            <span class="dict-def">${e.def}</span>
        </div>`;
}
function renderDict(query) {
    const q = normStr(query.trim());
    const el = document.getElementById('dictResults');
    if (!q) {
        el.innerHTML = DICT.map(dictItemHTML).join('');
        return;
    }
    const scored = DICT.flatMap(e => {
        const best = Math.max(fuzzyScore(e.normTerm, q) * 3, fuzzyScore(e.normDef, q));
        return best > 0 ? [{ e, score: best }] : [];
    });
    if (!scored.length) {
        el.innerHTML = `<div class="dict-empty">No results for "${query}"</div>`;
        return;
    }
    scored.sort((a, b) => b.score - a.score);
    el.innerHTML = scored.map(({ e }) => dictItemHTML(e)).join('');
}
document.getElementById('dictSearch').addEventListener('input', e => renderDict(e.target.value));
renderDict(''); // show all terms on load

// ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
initDB().then(()=>{
    updateBPM(bpm);
    droneSync();
    renderMemos();
});
</script>
<div id="viewport-flash"></div>
</body>
</html>
